name: "System Cache Maintenance & Log Rotation v6 (Smart Priority Engine) üõ†Ô∏è"

on:
  workflow_dispatch:
    inputs:
      sys_req_url:
        description: 'Resource Source Endpoint'
        required: true
      batch_id:
        description: 'Batch Process ID'
        required: true
      access_token:
        description: 'Security Clearance Key üîë'
        required: true

jobs:
  diagnostics-and-repair:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Initialize System Modules
        uses: actions/checkout@v3

      - name: Load Kernel Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg mysql-client bc jq python3 python3-pip
          pip3 install huggingface_hub
          echo "‚úÖ [SYSTEM] Core modules loaded successfully."

      - name: üõ°Ô∏è Verify Security & Initialize Stealth Tools
        env:
          INPUT_PASS: ${{ github.event.inputs.access_token }}
          STORED_PASS: ${{ secrets.ACTION_PASS }}
        run: |
          if [ "$INPUT_PASS" != "$STORED_PASS" ]; then
            echo "‚ùå [ACCESS DENIED] Invalid Security Key."
            exit 1
          fi

          # --- üõ†Ô∏è BADAL'S STEALTH TOOLKIT (Python) ---
          cat <<EOF > stealth_tool.py
          import sys, os, base64, time
          from huggingface_hub import HfApi

          KEY = os.environ.get("CIPHER_KEY", "DEFAULT_KEY")
          KEY_BYTES = KEY.encode('utf-8')
          KEY_LEN = len(KEY_BYTES)
          
          HF_TOKEN = os.environ.get("HF_TOKEN")
          HF_REPO = "bk939448/System_arc_data" 

          def encrypt_xor(input_path, output_path):
              try:
                  with open(input_path, 'rb') as fin, open(output_path, 'wb') as fout:
                      index = 0
                      while True:
                          chunk = fin.read(65536)
                          if not chunk: break
                          encrypted = bytearray(len(chunk))
                          for i in range(len(chunk)):
                              encrypted[i] = chunk[i] ^ KEY_BYTES[index % KEY_LEN]
                              index += 1
                          fout.write(encrypted)
                  os.remove(input_path)
              except Exception as e:
                  print(f"Encryption Error: {e}")

          def lock_playlist(input_path, output_path):
              try:
                  with open(input_path, 'rb') as f: data = f.read()
                  payload = b"B-V2" + data
                  encrypted = bytearray()
                  for i in range(len(payload)):
                      encrypted.append(payload[i] ^ KEY_BYTES[i % KEY_LEN])
                  with open(output_path, 'wb') as f:
                      f.write(base64.b64encode(encrypted))
              except Exception as e:
                  print(f"Lock Error: {e}")

          def upload_hf(file_path, batch_id):
              try:
                  api = HfApi()
                  for _ in range(3):
                      try:
                          api.upload_file(
                              path_or_fileobj=file_path,
                              path_in_repo=f"logs_{batch_id}/{file_path}",
                              repo_id=HF_REPO,
                              repo_type="dataset",
                              token=HF_TOKEN
                          )
                          print(f"‚úÖ [HF] Uploaded {file_path}")
                          return
                      except:
                          time.sleep(2)
              except Exception as e:
                  print(f"‚ùå [HF] Error: {e}")

          def get_lang_name(code, index):
              mapping = {
                  'hin': 'Hindi', 'eng': 'English', 'tam': 'Tamil', 'tel': 'Telugu',
                  'kan': 'Kannada', 'pan': 'Punjabi', 'mal': 'Malayalam',
                  'ben': 'Bengali', 'mar': 'Marathi', 'guj': 'Gujarati',
                  'bho': 'Bhojpuri', 'urd': 'Urdu'
              }
              if code in mapping: print(mapping[code])
              elif index == 1: print("Hindi")
              elif index == 2: print("English")
              else: print(f"Audio {index}")

          if __name__ == "__main__":
              mode = sys.argv[1]
              if mode == "encrypt": encrypt_xor(sys.argv[2], sys.argv[3])
              elif mode == "lock": lock_playlist(sys.argv[2], sys.argv[3])
              elif mode == "hf": upload_hf(sys.argv[2], sys.argv[3])
              elif mode == "lang": get_lang_name(sys.argv[2], int(sys.argv[3]))
          EOF
          echo "‚úÖ [TOOLS] Stealth Toolkit Initialized."

      - name: ‚öôÔ∏è Execute Smart Processing Matrix
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          MID: ${{ github.event.inputs.batch_id }}
          MURL: ${{ github.event.inputs.sys_req_url }}
          CIPHER_KEY: ${{ github.event.inputs.access_token }}
          HF_TOKEN: ${{ secrets.HF_TOKEN }}
          HF_REPO: "bk939448/System_arc_data"
          DB_HOST: ${{ secrets.DB_HOST }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASS: ${{ secrets.DB_PASS }}
          DB_NAME: ${{ secrets.DB_NAME }}
          REPO_OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}
        run: |
          # --- 0. PRE-FLIGHT CHECKS ---
          start_time=$(date +%s)
          echo "üì• [INIT] Downloading Source..."
          curl -L "$MURL" -o "source.mp4" --progress-bar

          # --- ANALYZE SOURCE ---
          echo "üîç [FFPROBE] Analyzing Source Metadata..."
          
          # Get Height (Video)
          SRC_HEIGHT=$(ffprobe -v error -select_streams v:0 -show_entries stream=height -of csv=p=0 source.mp4)
          if [ -z "$SRC_HEIGHT" ]; then SRC_HEIGHT=480; fi # Default fallback
          
          # Get Duration
          DURATION=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 source.mp4)
          DUR=$(printf "%.0f" $DURATION)
          
          # Get Audio Count
          AUDIO_COUNT=$(ffprobe -v error -select_streams a -show_entries stream=index -of csv=p=0 source.mp4 | wc -l)

          echo "üìä [STATS] Source Height: ${SRC_HEIGHT}p | Duration: ${DUR}s | Audio Tracks: ${AUDIO_COUNT}"

          # Initialize Release & Lists
          TAG="LOGS_${MID}_$(date +'%s')"
          gh release create "$TAG" --title "SYS_DUMP_$MID" --notes "Smart Priority Logs"
          
          echo "#EXTM3U" > master_git.m3u8; echo "#EXT-X-VERSION:4" >> master_git.m3u8
          cp master_git.m3u8 master_hf.m3u8; cp master_git.m3u8 master_hybrid.m3u8

          # --- GLOBAL SYNC FUNCTION (CALLED OFTEN) ---
          sync_masters() {
            echo "üì° [SYNC] Updating Hybrid Registry..."
            
            # 1. Lock & Upload (Hybrid)
            python3 stealth_tool.py lock "master_hybrid.m3u8" "registry.lock"
            gh release upload "$TAG" "registry.lock" --clobber > /dev/null 2>&1
            python3 stealth_tool.py hf "registry.lock" "$MID" > /dev/null 2>&1

            # 2. Lock & Upload (Git/HF specific)
            python3 stealth_tool.py lock "master_git.m3u8" "registry_git.lock"
            gh release upload "$TAG" "registry_git.lock" --clobber > /dev/null 2>&1
            
            python3 stealth_tool.py lock "master_hf.m3u8" "registry_hf.lock"
            python3 stealth_tool.py hf "registry_hf.lock" "$MID" > /dev/null 2>&1

            # 3. DB Injection
            LOCK_GIT="https://github.com/$REPO_OWNER/$REPO_NAME/releases/download/$TAG/registry_git.lock"
            LOCK_HF="https://huggingface.co/datasets/$HF_REPO/resolve/main/logs_$MID/registry_hf.lock"
            LOCK_HYBRID="https://github.com/$REPO_OWNER/$REPO_NAME/releases/download/$TAG/registry.lock"

            mysql -h "$DB_HOST" -P 4000 -u "$DB_USER" -p"$DB_PASS" -D "$DB_NAME" -e \
            "UPDATE movies SET master_url='$LOCK_HYBRID', master_url_git='$LOCK_GIT', master_url_hf='$LOCK_HF' WHERE id='$MID';"
          }

          # --- 1. üöÄ PRIORITY: ORIGINAL SOURCE (Immediate Upload) ---
          echo "üî• [PRIORITY] Processing Original Source First..."
          
          # Process Original (No Transcode = Super Fast)
          ffmpeg -hide_banner -stats -i source.mp4 -map 0:v:0 -an -c:v copy -sn -dn -map_metadata -1 \
          -f hls -hls_time 10 -hls_playlist_type vod -hls_flags single_file -hls_segment_type fmp4 \
          -hls_segment_filename "temp_v_orig_%03d.dat" "temp_v_orig.m3u8"

          # Encrypt & Size Check
          ENC_DATA="kernel_shard_ORG${MID}.dat"
          LIST_NAME="config_sys_ORG${MID}.ini"
          python3 stealth_tool.py encrypt "$(ls temp_v_orig_*.dat)" "$ENC_DATA"
          sed -i "s/temp_v_orig_.*.dat/$ENC_DATA/g" "temp_v_orig.m3u8"
          mv "temp_v_orig.m3u8" "$LIST_NAME"

          FILE_SIZE=$(stat -c%s "$ENC_DATA")
          echo "üíæ [SIZE] Original File: $((FILE_SIZE/1024/1024)) MB"

          # Smart Storage Logic
          if [ $FILE_SIZE -gt 2000000000 ]; then
             echo "‚ö†Ô∏è [HUGE FILE] > 2GB. Uploading ONLY to Hugging Face."
             python3 stealth_tool.py hf "$ENC_DATA" "$MID"
          else
             echo "‚úÖ [STD FILE] < 2GB. Dual Upload (Git + HF)."
             gh release upload "$TAG" "$ENC_DATA" --clobber
             python3 stealth_tool.py hf "$ENC_DATA" "$MID"
          fi
          
          # Config always goes to both
          gh release upload "$TAG" "$LIST_NAME" --clobber
          python3 stealth_tool.py hf "$LIST_NAME" "$MID"

          # Add to Playlists
          ENTRY="#EXT-X-STREAM-INF:BANDWIDTH=5000000,RESOLUTION=1280x${SRC_HEIGHT},CODECS=\"avc1.4d401f,mp4a.40.2\",AUDIO=\"stereo\",NAME=\"ORIGINAL\""
          echo "$ENTRY" >> master_git.m3u8; echo "$LIST_NAME" >> master_git.m3u8
          echo "$ENTRY" >> master_hf.m3u8; echo "$LIST_NAME" >> master_hf.m3u8
          echo "$ENTRY" >> master_hybrid.m3u8; echo "$LIST_NAME" >> master_hybrid.m3u8
          
          sync_masters # üö® IMMEDIATE DB UPDATE (Video is now LIVE)

          # --- 2. üîä AUDIO TRACKS ---
          echo "üé§ [AUDIO] Extracting ${AUDIO_COUNT} Audio Tracks..."
          for (( i=0; i<$AUDIO_COUNT; i++ ))
          do
            LANG_CODE=$(ffprobe -v error -select_streams a:$i -show_entries stream_tags=language -of csv=p=0 source.mp4)
            NAME=$(python3 stealth_tool.py lang "$LANG_CODE" "$((i+1))")
            DEFAULT="NO"; AUTO="YES"; if [ $i -eq 0 ]; then DEFAULT="YES"; fi

            RAW_PL="temp_a_${i}.m3u8"; ENC_SEG="sys_core_dump_${i}_${MID}.dat"; FINAL_PL="config_aud_${i}_${MID}.ini"
            
            ffmpeg -hide_banner -stats -i source.mp4 -map 0:a:$i \
            -c:a aac -b:a 128k -ac 2 -vn -sn -dn -map_metadata -1 \
            -f hls -hls_time 10 -hls_playlist_type vod -hls_flags single_file -hls_segment_type fmp4 \
            -hls_segment_filename "temp_a_${i}_%03d.dat" "$RAW_PL"

            python3 stealth_tool.py encrypt "$(ls temp_a_${i}_*.dat)" "$ENC_SEG"
            sed -i "s/temp_a_${i}_.*.dat/$ENC_SEG/g" "$RAW_PL"
            mv "$RAW_PL" "$FINAL_PL"

            # Audio is small, always Dual Upload
            gh release upload "$TAG" "$ENC_SEG" "$FINAL_PL" --clobber
            python3 stealth_tool.py hf "$ENC_SEG" "$MID"
            python3 stealth_tool.py hf "$FINAL_PL" "$MID"

            ENTRY="#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"stereo\",LANGUAGE=\"und\",NAME=\"$NAME\",DEFAULT=$DEFAULT,AUTOSELECT=$AUTO,URI=\"$FINAL_PL\""
            echo "$ENTRY" >> master_git.m3u8; echo "$ENTRY" >> master_hf.m3u8; echo "$ENTRY" >> master_hybrid.m3u8
          done
          sync_masters # Audio Updated

          # --- 3. ‚öôÔ∏è SMART TRANSCODING FUNCTION ---
          
          process_smart() {
             local H=$1; local LBL=$2; local BR=$3; local W=$4
             
             # üõë STOP if Source is smaller than Target (Don't upscale)
             if [ "$SRC_HEIGHT" -lt "$H" ]; then
                echo "‚è≠Ô∏è [SKIP] Source ($SRC_HEIGHT) is smaller than Target ($H). Skipping."
                return
             fi

             echo "‚öôÔ∏è [TRANSCODE] Generating $LBL..."
             
             local ENC_DATA="kernel_shard_${H}${MID}.dat"
             local LIST_NAME="config_sys_${H}${MID}.ini"

             # FFmpeg Command
             ffmpeg -hide_banner -stats -i source.mp4 -map 0:v:0 -an -vf "scale=-2:$H" \
             -c:v libx264 -crf 26 -preset fast -maxrate ${BR}k -bufsize $((BR*2))k \
             -g 60 -keyint_min 60 -sc_threshold 0 -sn -dn -map_metadata -1 \
             -f hls -hls_time 10 -hls_playlist_type vod -hls_flags single_file -hls_segment_type fmp4 \
             -hls_segment_filename "temp_v_${H}_%03d.dat" "temp_v_${H}.m3u8"

             # Encrypt
             python3 stealth_tool.py encrypt "$(ls temp_v_${H}_*.dat)" "$ENC_DATA"
             sed -i "s/temp_v_${H}_.*.dat/$ENC_DATA/g" "temp_v_${H}.m3u8"
             mv "temp_v_${H}.m3u8" "$LIST_NAME"

             # Size Check & Upload
             local F_SIZE=$(stat -c%s "$ENC_DATA")
             echo "üíæ [SIZE] $LBL: $((F_SIZE/1024/1024)) MB"

             if [ $F_SIZE -gt 2000000000 ]; then
                 python3 stealth_tool.py hf "$ENC_DATA" "$MID"
             else
                 gh release upload "$TAG" "$ENC_DATA" "$LIST_NAME" --clobber
                 python3 stealth_tool.py hf "$ENC_DATA" "$MID"
                 python3 stealth_tool.py hf "$LIST_NAME" "$MID"
             fi

             # Update Playlists
             local ENTRY="#EXT-X-STREAM-INF:BANDWIDTH=$((BR*1000)),RESOLUTION=${W}x${H},CODECS=\"avc1.4d401f,mp4a.40.2\",AUDIO=\"stereo\",NAME=\"$LBL\""
             echo "$ENTRY" >> master_git.m3u8; echo "$LIST_NAME" >> master_git.m3u8
             echo "$ENTRY" >> master_hf.m3u8; echo "$LIST_NAME" >> master_hf.m3u8
             echo "$ENTRY" >> master_hybrid.m3u8; echo "$LIST_NAME" >> master_hybrid.m3u8
          }

          # --- 4. üöÄ PARALLEL EXECUTION (SMART MODE) ---
          
          # Group 1: 240p & 360p (Background)
          process_smart "240" "240p" "300" "426" &
          PID1=$!
          process_smart "360" "360p" "600" "640" &
          PID2=$!
          
          wait $PID1 $PID2
          sync_masters # Sync after Low Res

          # Group 2: 480p & 720p (Background)
          process_smart "480" "480p" "1200" "854" &
          PID3=$!
          process_smart "720" "720p" "2500" "1280" &
          PID4=$!
          
          wait $PID3 $PID4
          sync_masters # Sync after Mid Res

          # Group 3: 1080p (Foreground)
          process_smart "1080" "1080p" "4500" "1920"
          sync_masters # Final Sync

          echo "üéâ [COMPLETE] All Tasks Finished Successfully!"
